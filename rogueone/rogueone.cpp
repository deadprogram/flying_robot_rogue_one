//////////////////////////////////////////////////////////////////////////
// Auto-generated by RAD
//////////////////////////////////////////////////////////////////////////
#include <WProgram.h>

#include <SoftwareSerial.h>

#include <Wire.h>
#include <Wire.h>
#include <Servo.h>
//////////////////////////////////////////////////////////////////////////
// plugin directives
//////////////////////////////////////////////////////////////////////////
#define LEFT_MOTOR  2
#define RIGHT_MOTOR 3
#define FORWARD 1
#define REVERSE 0
//////////////////////////////////////////////////////////////////////////
// method signatures
//////////////////////////////////////////////////////////////////////////
void loop();
void setup();
// sketch signatures
int main();
TwoWire& wire();
Servo& vectoring_servo();
SoftwareSerial& main_thrusters();
int main_thrusters_reset();
int led();
// plugin signatures




//////////////////////////////////////////////////////////////////////////
// plugin structs
//////////////////////////////////////////////////////////////////////////
void loop();
void hail();
void status();
void elevators();
void servo_delay(long t);
void rudder();
void throttle();
void instruments();
void additional_setup();

//////////////////////////////////////////////////////////////////////////
// plugin external variables
//////////////////////////////////////////////////////////////////////////
bool current_command_received_complete;
int current_command_length;
char command_buffer[120];
char command_code[1];
char direction_code[1];
char instrument_code[1];
int command_value;
int HMC6352Address = 0x42;
byte headingData[2];
int headingValue = 0;
int slaveAddress = HMC6352Address >> 1;
bool mc_init_complete;

//////////////////////////////////////////////////////////////////////////
// sketch external variables
//////////////////////////////////////////////////////////////////////////
byte __right_motor = 3;
byte __left_motor = 2;
byte __reverse = 0;
byte __forward = 1;

// servo_settings array

// debounce array

// hysteresis array

// spectrasymbol soft pot array


//////////////////////////////////////////////////////////////////////////
// variable and accessors
//////////////////////////////////////////////////////////////////////////
TwoWire _wire = TwoWire();
Servo _vectoring_servo = Servo();
void servo_refresh(void);
SoftwareSerial _main_thrusters = SoftwareSerial(10, 3);
int _main_thrusters_reset = 4;
int _led = 13;

        TwoWire& wire() {
          return _wire;
        }
        void begin( TwoWire& s) {
          return s.begin();
        }
        void begin( TwoWire& s, uint8_t a) {
          return s.begin(a);
        }
        void begin( TwoWire& s, int a) {
          return s.begin(a);
        }
        void beginTransmission( TwoWire& s, uint8_t a ) {
          return s.beginTransmission( a );
        }
        void beginTransmission( TwoWire& s, int a ) {
          return s.beginTransmission( a );
        }
        void endTransmission( TwoWire& s ) {
          return s.endTransmission();
        }
        void requestFrom( TwoWire& s, uint8_t a, uint8_t q) {
          return s.requestFrom( a, q );
        }
        void requestFrom( TwoWire& s, int a, int q) {
          return s.requestFrom( a, q );
        }
        void send( TwoWire& s, uint8_t d) {
          return s.send(d);
        }
        void send( TwoWire& s, int d) {
          return s.send(d);
        }
        void send( TwoWire& s, char* d) {
          return s.send(d);
        }
        void send( TwoWire& s, uint8_t* d, uint8_t q) {
          return s.send( d, q );
        }
        uint8_t available( TwoWire& s) {
          return s.available();
        }
        uint8_t receive( TwoWire& s) {
          return s.receive();
        }

        Servo& vectoring_servo() {
          return _vectoring_servo;
        }
        uint8_t attach( Servo& s, int p ) {
          return s.attach(p);
        }
        uint8_t attach( Servo& s, int p, int pos ) {
          return s.attach(p, pos );
        }
        uint8_t attach( Servo& s, int p, uint16_t mn, uint16_t mx ) {
          return s.attach(p, mn, mx);
        }
        uint8_t attach( Servo& s, int p, int pos, uint16_t mn, uint16_t mx ) {
          return s.attach(p, pos, mn, mx);
        }
        void detach( Servo& s ) {
          return s.detach();
        }
        void position( Servo& s, int b ) {
          return s.position( b );
        }
        void speed( Servo& s, int b ) {
          return s.speed( b );
        }
        uint8_t read( Servo& s ) {
          return s.read();
        }
        uint8_t attached( Servo& s ) {
          return s.attached();
        }
        static void refresh( Servo& s ) {
          return s.refresh();
        }

        SoftwareSerial& main_thrusters() {
        return _main_thrusters;
        }
        int read(SoftwareSerial& s) {
          return s.read();
        }
        void println( SoftwareSerial& s, char* str ) {
          return s.println( str );
        }
        void print( SoftwareSerial& s, char* str ) {
          return s.print( str );
        }
        void println( SoftwareSerial& s, int i ) {
          return s.println( i );
        }
        void print( SoftwareSerial& s, int i ) {
          return s.print( i );
        }

int main_thrusters_reset() {
	return _main_thrusters_reset;
}
int led() {
	return _led;
}

//////////////////////////////////////////////////////////////////////////
// assembler declarations
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// setup
//////////////////////////////////////////////////////////////////////////
void setup() {
	// pin modes
	pinMode(10, INPUT);
	pinMode(19, OUTPUT);
	pinMode(11, OUTPUT);
	pinMode(3, OUTPUT);
	pinMode(4, OUTPUT);
	pinMode(13, OUTPUT);
	// setup from plugins via add_to_setup method
	current_command_received_complete = false;
	mc_init_complete = false;
	// other setup
	_wire.begin();
	_vectoring_servo.attach(11, 544, 2400);
	_main_thrusters.begin(9600);
Serial.begin(9600);
	additional_setup();
}

void
additional_setup() {
NULL;
}
//////////////////////////////////////////////////////////////////////////
// helper methods
//////////////////////////////////////////////////////////////////////////

// RAD built-in helpers
void servo_refresh(void)
{
	Servo::refresh();
}

//////////////////////////////////////////////////////////////////////////
// plugin methods
//////////////////////////////////////////////////////////////////////////
void be_flying_robot(){}
  
  boolean current_command_received_is_complete() {
    return current_command_received_complete == true ;
  }
  
  char current_command() {
    return command_code[0];
  }

  char current_command_direction() {
    return direction_code[0];
  }

  char current_command_instrument() {
    return instrument_code[0];
  }
  
  int current_command_value() {
    return command_value ;
  }
  
  void clear_command_buffer() {
    for(int i=0; i<120; i++){
      command_buffer[i] = 0 ;
    }
    
    command_code[0] = 0 ;
    direction_code[0] = 0 ;
    instrument_code[0] = 0 ;
    current_command_length = 0 ;
    current_command_received_complete = false ;
  }
  
  void parse_command_code() {
    if(current_command_length == 0) {
      command_code[0] = 0;
    } else {
      command_code[0] = command_buffer[0];
    }
  }

  void parse_direction_code() {
    if(current_command_length >= 3) {
      direction_code[0] = command_buffer[2];
    } else {
      direction_code[0] = 0;
    }
  }

  void parse_instrument_code() {
    if(current_command_length >= 3) {
      instrument_code[0] = command_buffer[2];
    } else {
      instrument_code[0] = 0;
    }
  }

  void parse_command_value(int start) {
    if(current_command_length >= start + 1) {
      command_value = atoi(command_buffer + start);
    } else {
      command_value = 0 ;
    }
  }
  
  void get_command() {
    if(current_command_received_complete) {
      clear_command_buffer();
    }
    
    while(Serial.available() > 0) {
      command_buffer[current_command_length] = Serial.read();
      if(command_buffer[current_command_length] == '\r') {
        current_command_received_complete = true ;
        parse_command_code();
        return;
      } else {
        current_command_length++ ;
      }
    }
  }
  
  void dispatch_command() {
    if(!current_command_received_is_complete()) {
      return;
    }
    
    char cmd = current_command(); 
    
    if (cmd == 'h') {
      hail();
    } else if (cmd == 's') {  
      status();
    } else if (cmd == 'e') {
      parse_direction_code();
      parse_command_value(4);
      elevators();
    } else if (cmd == 'r') { 
      parse_direction_code();
      parse_command_value(4);
      rudder();
    } else if (cmd == 't') {
      parse_direction_code();
      parse_command_value(4);
      throttle();
    } else if (cmd == 'i') {    
      parse_instrument_code();
      instruments();
    } else {    
      Serial.println("Invalid command");
    }    
  }
  
  void process_command() {
    get_command();
    dispatch_command();
  }

void prepare_compass() {
    // hack to reference plugin, copied this trick from twitter plugin 
  }
  
  // The whole number part of the heading
  int heading()
  {
    return int (headingValue / 10) ;
  }
  
  // The fractional part of the heading
  int heading_fractional()
  {
    return int (headingValue % 10) ;
  }
  
  void read_compass()
  {
    // Send a "A" command to the HMC6352
    // This requests the current heading data
    Wire.beginTransmission(slaveAddress);
    Wire.send("A");              // The "Get Data" command
    Wire.endTransmission();
    delay(10);                   // The HMC6352 needs at least a 70us (microsecond) delay
    // after this command.  Using 10ms just makes it safe
    // Read the 2 heading bytes, MSB first
    // The resulting 16bit word is the compass heading in 10ths of a degree
    // For example: a heading of 1345 would be 134.5 degrees
    Wire.requestFrom(slaveAddress, 2);        // Request the 2 byte heading (MSB comes first)
    int i = 0;
    while(Wire.available() && i < 2)
    { 
      headingData[i] = Wire.receive();
      i++;
    }
    headingValue = headingData[0]*256 + headingData[1];  // Put the MSB and LSB together
  }

void mc_init(int motor_controller_reset_pin)
  {
    if (mc_init_complete) {
      return ;
    }
    
    mc_init_complete = true ;
      
    // start up motor controller
    digitalWrite(motor_controller_reset_pin, HIGH);

    // let motor controller wake up
    delay(100);
  }

  void mc_send_command(SoftwareSerial& motor_controller, byte motor, byte direction, byte speed)
  {
    unsigned char mc_command[4];
    direction = constrain(direction, 0,   1);
    speed     = constrain(speed,   0, 127);

    mc_command[0] = 0x80; // start byte
    mc_command[1] = 0x00; // Device type byte
    mc_command[2] = (2 * motor) + (direction == FORWARD ? FORWARD : REVERSE); // Motor number and direction byte
    mc_command[3] = speed; // Motor speed (0 to 127)

    // send data
    for(int i = 0; i < 4; i++)
    { motor_controller.print(mc_command[i], BYTE); }
  }


// serial helpers
int serial_available() {
          return (Serial.available() > 0);
        }
        
        char serial_read() {
          return (char) Serial.read();
        }
        
        void serial_flush() {
          return Serial.flush();
        }

        void serial_print( char str ) {
          return Serial.print( str );
        }

        void serial_print( char* str ) {
          return Serial.print( str );
        }

        void serial_print( int i ) {
          return Serial.print( i );
        }

        void serial_print( long i ) {
          return Serial.print( i );
        }

      	void serial_println( char* str ) {
          return Serial.println( str );
        }

        void serial_println( char str ) {
          return Serial.println( str );
        }

      	void serial_println( int i ) {
          return Serial.println( i );
        }

        void serial_println( long i ) {
          return Serial.println( i );
        }

        void serial_print( unsigned long i ) {
          return Serial.print( i );
        }


//////////////////////////////////////////////////////////////////////////
// main() function
//////////////////////////////////////////////////////////////////////////
int main() {
	init();
	setup();
	for( ;; ) { loop(); }
	return 0;
}

//////////////////////////////////////////////////////////////////////////
// loop!  Autogenerated by RubyToC, sorry it's ugly.
//////////////////////////////////////////////////////////////////////////
void
loop() {
be_flying_robot();
process_command();
servo_refresh();
}
void
hail() {
serial_println("Roger");
}
void
status() {
serial_println("Status: operational");
}
void
elevators() {
serial_print("Elevators command - direction:");
serial_print(current_command_direction());
serial_print(" value:");
serial_println(current_command_value());
servo_refresh();
position(vectoring_servo(), current_command_value());
}
void
servo_delay(long t) {
long temp_1;
temp_1 = 0;
while (temp_1 < t) {
delay(1);
servo_refresh();
;
temp_1 = temp_1 + 1;
}
}
void
rudder() {
serial_print("Rudder command - direction:");
serial_print(current_command_direction());
serial_print(" value:");
serial_println(current_command_value());
}
void
throttle() {
mc_init(main_thrusters_reset());
if (current_command_direction() == 'f') {
mc_send_command(main_thrusters(), __left_motor, __forward, current_command_value());
mc_send_command(main_thrusters(), __right_motor, __forward, current_command_value());
};
if (current_command_direction() == 'r') {
mc_send_command(main_thrusters(), __left_motor, __reverse, current_command_value());
mc_send_command(main_thrusters(), __right_motor, __reverse, current_command_value());
};
serial_print("Throttle command - direction:");
serial_print(current_command_direction());
serial_print(" value:");
serial_println(current_command_value());
}
void
instruments() {
prepare_compass();
read_compass();
serial_print("Instruments command - compass heading:");
serial_print(heading());
serial_print('.');
serial_println(heading_fractional());
}
